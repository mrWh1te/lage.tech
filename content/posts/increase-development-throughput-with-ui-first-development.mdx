---
title: Increase FE development throughput with UI first
date: 2020-01-03
---

# Development Feedback Loop

Here is a high-level view of the proven *iterative* process of developing new features and fixing bugs in applications: 

<center>
    <img src="/iterative-development-loop.png" alt="Iterative Development Loop" />
</center>

1. Develop code based on an user story, requirements, design assets
2. Deploy code changes to testing environment (i.e. Staging)
3. Collect feedback from stakeholders (i.e. new designs, scope revisions)
4. Repeat until satisfied

# O( 2n )

From the Frontend point of view, most complex application features' code is made of at least two distinct components:

<center>
    <img src="/iterative-development-smart-ui-leg-2n.png" alt="Traditional Development Leg consisting of two components to iterate on each time" />
</center>

1. Smart / business logic
2. UI

In the Development Feedback Loop, each pass through the Development leg, has developers rewriting two components that handle different problems such as styling UI with CSS or sorting incoming data from an API response.

We can think of these two camps of code as two different chores, requiring two different trains of thought, a developer must take time to deal with, for each pass of the Development Feedback Loop.

We can describe the upper limit of component (re)writes, per feature, by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation):

<center>O( 2n )</center>

For every feature, a FE team develops, they may rewrite component code up to 2n for the number of feedback loop iterations.

For example, a whole team (Product, Design, Development, BA's, etc) completes a new feature after iterating *four times*. During which, FE developers may rewrite components' code up to *eight times*. That is up to four times rewriting a smart component, and up to four times rewriting an UI component.

If each component rewrite takes 1-3 hours, it will take 8-24 hours of developer time to rewrite the components to complete one feature.

We can do better, by refining what the team iterates on.

## UI first Development

UI first development leverages documentation tools such as [Docz]() or [Storybook](), to not only provide a more collaborative experience for all stakeholders, but to increase the throughput of developers' time, by reducing the amount of code developers rewrite during the iterative process of the feedback loop.

First, developers setup a new feature's UI component, **once**, inside the team's documentation tool. It can look as simple as this [real example](https://github.com/mrWh1te/gardn/blob/master/libs/ui/src/lib/logo/logo.stories.tsx), or even be partially generated, depending on your setup (i.e. [Nx](https://nx.dev/latest/angular/plugins/storybook/overview#auto-generate-stories)).

Then the developer builds out the UI component inside the documentation tool, to deploy the tool for collecting feedback with all stakeholders. Together, the team focuses on the UI component first, before getting into the weeds of the smart, business logic.

Once the UI component is complete, the developers write the Smart component, **once**.

Therefore, we can describe the upper limit of component (re)writes, per feature, by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation):

<center>n + 2</center>

It's *one* time to setup the Story or Docz markdown page (almost negligible), for the UI component. It's *n* times of repeating the Development Feedback Loop in rewriting, just, the UI component. Finally, it's *one* time to write the Smart component. That is where is the time is saved, by reducing the amount of times developers may rewrite smart components.

## Comparing 2n, n + 2

n + 2 is shorter than 2n, except for when the feedback loop repeats only once. The moment the feedback sends the developers to rewrite code, it's the beginning of the second loop, where the development times are equal, but the value is more. 

Here's a graph of n + 2 (UI first with UI documentation) versus 2n (traditional without UI documentation):

<center>
    <img src="/graph_2n_versus_n+2.png" alt="Graph of f(n)=2n and f(n)=n+2" style="border: 1px solid black" />
</center>

For example, there is an User Story to build out a new *Blog Post Viewer*. This particular story ends up taking a team four full iterations, in the feedback loop.

Traditionally, for each iteration, the frontend developers might rewrite both Smart & UI components code of the Blog Post Viewer. To count the number of times developers work on a component's code, we plug in the amount of times the team(s) repeats the iterative process: 

<center>2(n) = 2(4) = 8</center>

Therefore, frontend developers will work on component's code up-to eight times, for that single feature.

This is opposed to UI first development:

<center>n + 2 = 4 + 2 = 6</center>

By iterating only on the UI, the number of times frontend developers need to rewrite components reduces. With this process, developer throughput increases by reducing the time it takes to iterate on complex features and by providing an amazing UI documentation tool. But, perhaps most importantly of all, this documentation tool and process refines the focus in the collaborative spirit of application development, which manages the complexity by reducing what's handled at a time.

## How many features do you plan to deliver?

If you're interested in improving your team's throughput, culture, or architecture, just reach out by email to <a href="mailto:lage.michael@gmail.com=Meet and Greet">lage.michael@gmail.com</a> with the subject, "Meet and Greet", and I'll send you a link to schedule a quick meeting.