---
title: Increase FE development throughput with UI first
date: 2020-01-03
---

# Development Feedback Loop

Here is a high-level view of the proven *iterative* process of developing new features and fixing bugs in applications: 

<center>
    <img src="/iterative-development-loop.png" alt="Iterative Development Loop" />
</center>

1. Develop code based on an user story, requirements, design assets
2. Deploy code changes to testing environment (i.e. Staging)
3. Collect feedback from stakeholders (i.e. new designs, scope revisions)
4. Repeat until satisfied

# O( 2n )

From the Frontend point of view, most application features' code has two distinct types: 
1. Smart business logic
2. UI

<center>
    <img src="/iterative-development-smart-ui-leg-2n.png" alt="Traditional Development Leg consisting of two components to iterate on each time" />
</center>

In the Development Feedback Loop of new features, each pass through the Development leg, has developers writing two distinct types of code that handle different problems, with their own solutions such as styling UI with CSS versus sorting incoming data from an API response.

We can think of these two camps of code as two different chores, a developer must take time to deal with, on each pass of the Development Feedback Loop. We can count the upper limit of code types (i.e. components) being iterated per feature by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation):

<center>O( 2n )</center>

For every feature or bug, a FE team develops, it may be up to 2n times of component code iterations to complete the feature.

For example, if the whole team (Product, Design, Development, BA's, etc) repeats the Development Feedback Loop together, *four times*, to complete a feature, FE developers may rewrite components up to *eight times*. That is up to four times rewriting a smart component, and up to four times rewriting an UI component. If each component rewrite takes 1-3 hours, it will take 8-24 hours of developer time to rewrite the components to complete one feature.

We can shorten the developer time by refining what is iterated on on each leg of the Development Feedback Loop.

## UI first Development

UI first development leverages tools such as Docz and Storybook, to not only provide a more collaborative experience for all stakeholders, but increase the throughput value of developers' time by reducing the amount of code developers rewrite (refactor).

These tools enable FE teams to iterate on *only* the UI component of a new feature, in each pass of the Development Feedback Loop. Once the UI is satisfactory, developers can write the Smart component, for the feature, once. Therefore, we can count the upper limit of code types (i.e. components) being iterated per feature by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation)

<center>n + 2</center>

It's *one* time to write the Smart component. It's (mostly) *one* time to write the "Story" or Docz markdown page, to setup the UI iterative development for the new feature. Then it's *n* times of repeating the Development Feedback Loop in rewriting *only* the UI component.

## Compare Lengths: 2n > n + 2

n + 1 is shorter than 2n, but doesn't represent the complete development picture for this workflow. With UI first development, using Storybook, for example, each UI component will need "stories" coded as well. Thankfully, if you're unfamiliar with it, "stories" are really simple and can even be generated (i.e. [using Nx](https://nx.dev/latest/angular/plugins/storybook/overview#auto-generate-stories)). They take less time to code than Smart or UI components. The time it takes to build a "story" is almost neligble (see this [example](https://github.com/mrWh1te/gardn/blob/master/libs/ui/src/lib/logo/logo.stories.tsx) for an UI Logo component). But, if you're new with Storybook, we can adjust our Big-O representation of this process by adding `1` to it, as if we're adding a whole other "smart" component, in terms of development work (that should cover us):

<center>n + 2</center>

This shortens the length of the development arch in the feedback loop. Here's a graph of n + 2 versus 2n:



For example, you have a User Story to build out a new *Blog Post Viewer*. Let's say, it takes 4 iterations, in this feedback loop, to complete it with satisfactory results for all stakeholders.

Traditionally, for each iteration, developers may rewrite or edit both Smart & UI component code of the new feature. To count the number of times developers work on a component's code, we plug in the amount of times the team(s) repeats the iterative process: 

<center>2(n) = 2(4) = 8</center>

Therefore, developers will work on component's code up-to that many times, for that single feature.

This is how UI first development increases developer throughput. By revising the approach, to use UI first development, we count the number of times developers work on a component's code, by plugging in the number of team iterations:

<center>n + 2 = 4 + 2 = 6</center>

Realistically, by using this process, the number of times your developers need to work on component code reduces. With this process, developer throughput increases, not to mention, you now have an *amazing* resource of UI component Documentation.

You can see up to 50% reduction in developer time for building out new complex features, when using this process. It can be even more valuable for teams that are exploring design ideas (UI/UX), like when building out a Style Guide as it reduces the developer work to build out demo's to discuss amongst stakeholders.

If it takes about 3-4 development hours for a single leg of iteration, we're talking between 6-8 hours of development time saved, for this one feature.

Therefore, the number of working hours to complete a new feature, will on average, take less time and therefore cost less, or for the same hours of cost, the throughput of work increases. Depending on how you want to look at it.

In this example, you might save up-to 16 hours of developer time. If each component iteration takes about 5 hours, the team could save 16 hours for just one feature.

Typically, working on a single component takes from 1 to 6 hours, maybe 3-4 hours.

## How many features do you plan to deliver this year?

If you're interested in improving your team's throughput, culture, or architecture, just reach out by email to <a href="mailto:lage.michael@gmail.com=Meet and Greet - Michael Lage">lage.michael@gmail.com</a> with the subject, "Meet and Greet - Michael Lage", and I'll send you a link to schedule a quick meeting.