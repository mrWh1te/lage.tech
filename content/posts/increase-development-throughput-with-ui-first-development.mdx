---
title: Increase FE development throughput with UI first
date: 2020-01-03
---

# Development Feedback Loop

Here is a high-level view of the proven *iterative* process of developing new features and fixing bugs in applications: 

<center>
    <img src="/iterative-development-loop.png" alt="Iterative Development Loop" />
</center>

1. Develop code based on an user story, requirements, design assets
2. Deploy code changes to testing environment (i.e. Staging)
3. Collect feedback from stakeholders (i.e. new designs, scope revisions)
4. Repeat until satisfied

# O( 2n )

From the Frontend point of view, most complex application features' code is made of at least two distinct components:

<center>
    <img src="/iterative-development-smart-ui-leg-2n.png" alt="Traditional Development Leg consisting of two components to iterate on each time" />
</center>

1. Smart / business logic
2. UI

In the Development Feedback Loop, each pass through the Development leg, has developers rewriting two components that handle different problems such as styling UI with CSS or sorting incoming data from an API response.

We can think of these two camps of code as two different chores, requiring two different trains of thought, a developer must take time to deal with, for each pass of the Development Feedback Loop.

We can describe the upper limit of component (re)writes, per feature, by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation):

<center>O( 2n )</center>

For every feature, a FE team develops, they may rewrite component code up to 2n for the number of feedback loop iterations.

For example, a whole team (Product, Design, Development, BA's, etc) completes a new feature after iterating *four times*. During which, FE developers may rewrite components' code up to *eight times*. That is up to four times rewriting a smart component, and up to four times rewriting an UI component.

If each component rewrite takes 1-3 hours, it will take 8-24 hours of developer time to rewrite the components to complete one feature.

We can do better, by refining what the team iterates on.

## UI first Development

UI first development leverages documentation tools such as [Docz]() or [Storybook](), to not only provide a more collaborative experience for all stakeholders, but to increase the throughput of developers' time, by reducing the amount of code developers rewrite during the iterative process of the feedback loop.

First, developers setup a new feature's UI component, **once**, inside the team's documentation tool. It can look as simple as this [real example](https://github.com/mrWh1te/gardn/blob/master/libs/ui/src/lib/logo/logo.stories.tsx), or even be partially generated, depending on your setup (i.e. [Nx](https://nx.dev/latest/angular/plugins/storybook/overview#auto-generate-stories)).

Then the developer builds out the UI component inside the documentation tool, to deploy the tool for collecting feedback with all stakeholders. Together, the team focuses on the UI component first, before getting into the weeds of the smart, business logic.

Once the UI component is complete, the developers write the Smart component, **once**.

Therefore, we can describe the upper limit of component (re)writes, per feature, by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation):

<center>n + 2</center>

It's *one* time to setup the Story or Docz markdown page (almost negligible), for the UI component. It's *n* times of repeating the Development Feedback Loop in rewriting, just, the UI component. Finally, it's *one* time to write the Smart component. That is where is the time is saved, by reducing the amount of times developers may rewrite smart components.

## Compare Lengths: 2n > n + 2

n + 2 is shorter than 2n.. 

Here's a graph of n + 2 versus 2n:
<center>
    <img src="/graph_2n_versus_n+2.png" alt="Graph of f(n)=2n and f(n)=n+2" />
</center>

For example, you have a User Story to build out a new *Blog Post Viewer*. It will take four iterations, in the feedback loop, to complete it to satisfaction for all stakeholders.

Traditionally, for each iteration, FE developers might rewrite or edit both Smart & UI component code of the new feature. To count the number of times developers work on a component's code, we plug in the amount of times the team(s) repeats the iterative process: 

<center>2(n) = 2(4) = 8</center>

Therefore, developers will work on component's code up-to that many times, for that single feature.

This is how UI first development increases developer throughput. By revising the approach, to use UI first development, we count the number of times developers work on a component's code, by plugging in the number of team iterations:

<center>n + 2 = 4 + 2 = 6</center>

By iterating on the UI only, the number of times your developers need to rewrite component code reduces. With this process, developer throughput increases, not to mention, you now have an *amazing* resource for UI collaboration and component documentation.

## How many features do you plan to deliver?

If you're interested in improving your team's throughput, culture, or architecture, just reach out by email to <a href="mailto:lage.michael@gmail.com=Meet and Greet">lage.michael@gmail.com</a> with the subject, "Meet and Greet", and I'll send you a link to schedule a quick meeting.