---
title: Increase FE development throughput with UI first
date: 2020-01-03
---

The Development Feedback Loop is a proven *iterative* process for developing new features and fixing hard-to-describe bugs. From a high-level, it follows:

<center>
    <img src="/iterative-development-loop.png" alt="Development Feedback Loop" />
</center>

1. Develop code based on a feature, user story, requirements, design assets
2. Deploy code changes to testing environment (i.e. Staging)
3. Collect feedback from stakeholders (i.e. new designs, scope revisions)
4. Repeat until complete

# O( 2n )

From the frontend developer's point of view, most feature code is split into two distinct components:

<center>
    <img src="/iterative-development-smart-ui-leg-2n.png" alt="Traditional Development Leg consisting of two components to iterate on each time" />
</center>

1. Smart / business logic
2. UI

We can estimate the number of times a component is rewritten, based on an application's feature architecture. In this case, we can describe the upper limit of times components are rewritten, per feature, by borrowing [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation):

<center>O( 2n )</center>

For every feature, a FE team develops, the FE developers may rewrite components up to 2n, when is is the number of full iterations in the feedback loop.

For example, a whole team (Product, Design, Development, BA's, etc) completes a new feature after iterating together, *four times*. During which, FE developers may rewrite components' code up to *eight times*, for this single feature. That is up to four times rewriting a smart component, and up to four times rewriting an UI component.

If each component (re)write takes 1-3 hours, it will take 8-24 hours of developer time to complete the feature.

We can improve this, by refining what the team iterates on.

## UI first Development

UI first development leaves out the Smart component until the very end of the iterative cycle, to reduce the number of times it's written, to one. By leveraging documentation tools such as [Docz](https://www.docz.site/) or [Storybook](https://storybook.js.org/), team's create collaborative, central experience for all stakeholders, while giving themselves a tool to increase the throughput of their time, by reducing the amount of code developers rewrite, to build new features and build valuable UI documentation.

<center>
    <img src="/ui-first-development-loop.png" alt="UI 1st Development loops on the UI only then does the smart, business logic once" />
</center>

When developers start on a new feature, they first setup a new UI component, **once**, inside the team's documentation tool. It can look as simple as this creating a [story that returns a Logo component](https://github.com/mrWh1te/gardn/blob/master/libs/ui/src/lib/logo/logo.stories.tsx). This step can partially be generated, depending on your setup (i.e. [Nx](https://nx.dev/latest/angular/plugins/storybook/overview#auto-generate-stories)).

Then the developers iterate on the UI component, first, inside the documentation tool, to deploy for feedback with all stakeholders. The team, can asynchronously, visit the documentation tool, interact with it, to provide feedback, before ever getting into the weeds of the smart, business logic.

Once the UI is complete, the developers write the Smart component, **once**.

Therefore, we can describe the upper limit of times components are rewritten, per feature, as such:

<center>O( n + 2 )</center>

*One* time to setup the Story or Docz markdown page (almost negligible). It's *n* times of rewriting the UI component during the iterative Development Feedback Loop. Finally, it's *one* time to write the Smart component for the set UI. That is where is the time is saved, by reducing the potential number of times developers might rewrite the smart components.

## Comparing 2n, n + 2

O( n + 2 ) is shorter than O( 2n ), except for when features are iterated twice or less. This process of development may not be worth the cost, for small projects, things just starting. 

However, if the project will scale with more stakeholders, the iterative loop will grow, and in that, UI first development will save developer time and provide useful UI documentation.

Here's a graph of UI first development (n + 2) and original development (2n):

<center>
    <img src="/graph_2n_versus_n+2.png" alt="Graph of f(n)=2n and f(n)=n+2" style="border: 1px solid black; margin-bottom: 0;" />
    <sub>*y-value represents the upper limit of component (re)writes for n iterations</sub>
</center>

As you see, the more complex the feature, the more exploratory the phase of development, the cheaper and more valuable it becomes, to iterate on the UI until completion, before even starting on the business logic. The UI, after all, sets requirements for the business services to serve.

For example, there is an User Story to build out a new *Blog Post Viewer*. This particular story ends up taking a team, four full iterations, to complete. The team's PM goes back with design and analytics to consider the most important sorting features to be included in this section of the web app.

Originally, for each iteration, the frontend developers rewrite both Smart & UI components for this experimental *Blog Post Viewer*. To count the number of times developers work on components, we plug in the amount of times the team iterates on the feature: 

<center>O( 2n ) = 2*4 = 8</center>

Therefore, frontend developers have written component code up-to eight times, for this feature.

This is opposed to UI first development, where the developers iterate only on the UI, reducing the number of component rewrites to complete the feature:

<center>O( n + 2 ) = 4 + 2 = 6</center>

By iterating only on the UI, the number of times frontend developers need to rewrite components reduces!

This process increases FE developer throughput by reducing the time it takes to iterate on complex features while providing amazing UI documentation. But, perhaps most importantly of all, this documentation tool and process, refines the focus of the team's collaborative spirit, in building new features. It's a way to manage complexity, therefore, manage the risk of handling too much during a single sprint.

## How many features do you plan to deliver?

If you're interested in improving your team's throughput, culture, architecture; reach out to schedule a Meet & Greet by emailing <a href="mailto:lage.michael@gmail.com=Meet and Greet">lage.michael@gmail.com</a> with the subject, "Meet and Greet". I'll send you a scheduling link.